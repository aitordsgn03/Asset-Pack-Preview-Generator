---
import { fileURLToPath } from "url";
import path from "node:path";
import fs from "node:fs/promises";
import Footer from "@/components/Footer.astro";
import Layout from "@/layouts/layout.astro";

interface Texture {
  name: string;
  path: string;
}

interface Model {
  name: string;
  path: string;
  preview_image: string;
  vertex_count: number;
  mesh_count: number;
  mesh_names: string[];
  has_animations: boolean;
  animation_count: number;
  animation_names: string[];
  materials: string[];
}

interface Pack {
  pack_name: string;
  description: string;
  author: string;
  stats: {
    total_models: number;
    total_animations: number;
  };
  textures: Texture[];
  models: Model[];
}

export async function getStaticPaths() {
  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const dataPath = path.join(__dirname, "../../../src/data");

  const files = await fs.readdir(dataPath);
  const jsonFiles = files.filter((file) => file.endsWith(".json"));

  const paths = await Promise.all(
    jsonFiles.map(async (file) => {
      const content = await fs.readFile(path.join(dataPath, file), "utf-8");
      const data = JSON.parse(content) as Pack;
      const slug = file.replace(".json", "");

      // Modificar las rutas para usar paths relativos
      const modifiedData = {
        ...data,
        models: data.models.map((model) => ({
          ...model,
          preview_image: `../../preview_images/${path.basename(model.preview_image)}`,
        })),
        textures: data.textures.map((texture) => ({
          ...texture,
          path: `../../textures/${path.basename(texture.path)}`,
        })),
      };

      return {
        params: { slug },
        props: { pack: modifiedData },
      };
    }),
  );

  return paths;
}

const { pack } = Astro.props;

function formatModelTitle(model: Model): string {
  const parts = [
    `${model.vertex_count} vertices`,
    `${model.mesh_count} group${model.mesh_count !== 1 ? "s" : ""}`,
    model.has_animations
      ? `${model.animation_count} animation${model.animation_count !== 1 ? "s" : ""}`
      : "0 Aniamtions",
  ];

  return parts.join(" • ");
}
---

<Layout
  title={pack.pack_name}
  description={pack.description}
  author={pack.author}
>
  <body>
    <div class="container header">
      <h1>{pack.pack_name}</h1>
      <p>{pack.description}</p>
    </div>
    <div class="container content">
      <h2 id="info">Information</h2>
      <p>
        If you need help importing the models to your game engine you can
        contact me if you need.
      </p>
      <p>
        <span class="data"
          ><strong>Total objects:</strong> {pack.stats.total_models}×</span
        >
        <span class="data"
          ><strong>Total animations:</strong>
          {pack.stats.total_animations}×</span
        >
      </p>
    </div>
    <div class="container content">
      <h3>Textures</h3>
      <p>
        {
          pack.textures.map((texture) => (
            <a
              href={texture.path}
              target="_blank"
              rel="noopener noreferrer"
              class="data no-padding"
            >
              <span
                class="swatch"
                style={`background-image: url("${texture.path}")`}
              />
              {texture.name}
            </a>
          ))
        }
      </p>
    </div>
    <div class="container content">
      <h3>Models</h3>
      {
        pack.models.map((model) => (
          <div title={formatModelTitle(model)} class="package">
            {model.has_animations && <span class="animated">ANIMATED</span>}
            <img src={model.preview_image} alt={model.name} loading="lazy" />
            <br />
            {model.name}
            <div class="model-info">
              {model.has_animations && (
                <span>
                  {model.animation_count} anim
                  {model.animation_count !== 1 ? "s" : ""}
                </span>
              )}
            </div>
          </div>
        ))
      }
    </div>
  </body>
</Layout>
